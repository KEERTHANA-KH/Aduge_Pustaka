from flask import Flask, render_template, redirect, url_for
from flask_login import LoginManager, current_user
from config import Config
from database.mysql_setup import init_mysql, create_tables
from database.mongo_setup import init_mongo

# Import blueprints
from routes.auth_routes import auth_bp
from routes.recipe_routes import recipe_bp
from routes.inventory_routes import inventory_bp
from routes.meal_plan_routes import meal_plan_bp

# Import models
from models.user import User
from models.recipe import Recipe  # Add this import

# Create Flask app
app = Flask(__name__)
app.config.from_object(Config)

# Initialize database connections
mysql_connection = init_mysql(app)
mongo_db = init_mongo(app)

# Create database tables
create_tables()

# Initialize Flask-Login
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'auth.login'

@login_manager.user_loader
def load_user(user_id):
    return User.get_by_id(user_id)

# Register blueprints
app.register_blueprint(auth_bp)
app.register_blueprint(recipe_bp)
app.register_blueprint(inventory_bp)
app.register_blueprint(meal_plan_bp)

# Add Recipe class to template context
@app.context_processor
def utility_processor():
    return {'Recipe': Recipe}

@app.route('/')
def index():
    return render_template('index.html')

if __name__ == '__main__':
    app.run(debug=True)

..................................

from database.mongo_setup import mongo_db
from bson.objectid import ObjectId
import os
from flask import current_app

print(f"Mongo DB connected: {mongo_db is not None}")

class Recipe:
    @staticmethod
    def get_image_path(recipe_id, image_url=None):
        """Return the local path to a recipe image or use placeholder if it doesn't exist"""
        # First try using recipe ID-based filename
        local_path = f"images/recipes/{recipe_id}.jpg"
        full_path = os.path.join(current_app.static_folder, local_path)
        
        if os.path.exists(full_path):
            return local_path
        
        # Fall back to placeholder
        return "images/placeholder.jpg"
        
    @staticmethod
    def get_all():
        return list(mongo_db.recipes.find())
    
    @staticmethod
    def get_by_id(recipe_id):
        try:
            return mongo_db.recipes.find_one({"_id": ObjectId(recipe_id)})
        except:
            return None
    
    @staticmethod
    def search_by_ingredients(ingredients_list, exclude_ingredients=None):
        """
        Search for recipes that can be made with the given ingredients
        
        Args:
            ingredients_list (list): List of ingredients names
            exclude_ingredients (list, optional): List of ingredients to exclude
            
        Returns:
            list: List of recipes that can be made with the given ingredients
        """
        if not ingredients_list:
            return []
        
        # Create query to match recipes with ingredients from the list
        query = {
            "ingredients.name": {
                "$in": ingredients_list
            }
        }
        
        # Add exclusion if provided
        if exclude_ingredients:
            query["ingredients.name"] = {
                "$nin": exclude_ingredients
            }
        
        # Find recipes and calculate match percentage
        recipes = list(mongo_db.recipes.find(query))
        
        # Calculate match percentage for each recipe
        for recipe in recipes:
            total_ingredients = len(recipe["ingredients"])
            matching_ingredients = sum(1 for i in recipe["ingredients"] if i["name"] in ingredients_list)
            recipe["match_percentage"] = (matching_ingredients / total_ingredients) * 100
        
        # Sort by match percentage (highest first)
        recipes.sort(key=lambda x: x.get("match_percentage", 0), reverse=True)
        
        return recipes
    
    @staticmethod
    def filter_by_dietary(recipes, dietary_filters):
        """
        Filter recipes based on dietary preferences
        
        Args:
            recipes (list): List of recipes to filter
            dietary_filters (dict): Dictionary of dietary filters
            
        Returns:
            list: Filtered list of recipes
        """
        if not dietary_filters:
            return recipes
        
        filtered_recipes = []
        
        for recipe in recipes:
            # Check if recipe matches all dietary filters
            matches_all = True
            
            for key, value in dietary_filters.items():
                if value and recipe.get("dietary_info", {}).get(key) != value:
                    matches_all = False
                    break
            
            if matches_all:
                filtered_recipes.append(recipe)
        
        return filtered_recipes
    
    @staticmethod
    def filter_by_time(recipes, max_time):
        """
        Filter recipes by maximum time
        
        Args:
            recipes (list): List of recipes to filter
            max_time (int): Maximum total time in minutes
            
        Returns:
            list: Filtered list of recipes
        """
        if not max_time:
            return recipes
        
        return [r for r in recipes if (r.get('prep_time', 0) + r.get('cook_time', 0)) <= max_time]
    
    @staticmethod
    def filter_by_difficulty(recipes, difficulty):
        """
        Filter recipes by difficulty level
        
        Args:
            recipes (list): List of recipes to filter
            difficulty (str): Difficulty level ('Easy', 'Medium', 'Hard')
            
        Returns:
            list: Filtered list of recipes
        """
        if not difficulty:
            return recipes
        
        return [r for r in recipes if r.get('difficulty') == difficulty]
    
    @staticmethod
    def search_by_name(search_term):
        """
        Search for recipes by name
        
        Args:
            search_term (str): Term to search for
            
        Returns:
            list: List of recipes matching the search term
        """
        if not search_term:
            return []
        
        # Create text index if it doesn't exist
        if "name_text" not in mongo_db.recipes.index_information():
            mongo_db.recipes.create_index([("name", "text"), ("description", "text")])
        
        return list(mongo_db.recipes.find({"$text": {"$search": search_term}}))
    
    @staticmethod
    def get_recipe_ingredients(recipe_id):
        """
        Get ingredients for a specific recipe
        
        Args:
            recipe_id (str): Recipe ID
            
        Returns:
            list: List of ingredients for the recipe
        """
        recipe = Recipe.get_by_id(recipe_id)
        if not recipe:
            return []
        
        return recipe.get("ingredients", [])

,.............................................


from database.mysql_setup import get_connection
from datetime import datetime, timedelta
from config import Config
from database.mongo_setup import mongo_db
import pymongo

class Inventory:
    def __init__(self, id, user_id, ingredient_name, category, quantity, unit, expiry_date=None, added_date=None, ingredient_id=None):
        self.id = id
        self.user_id = user_id
        self.ingredient_name = ingredient_name
        self.category = category
        self.quantity = quantity
        self.unit = unit
        self.expiry_date = expiry_date
        self.added_date = added_date
        self.ingredient_id = ingredient_id
    
    @staticmethod
    def get_by_user_id(user_id):
        conn = get_connection()
        cursor = conn.cursor(dictionary=True)
        
        cursor.execute(
            "SELECT * FROM inventory WHERE user_id = %s ORDER BY ingredient_name",
            (user_id,)
        )
        
        inventory_items = []
        for item in cursor.fetchall():
            inventory_items.append(Inventory(
                id=item['id'],
                user_id=item['user_id'],
                ingredient_name=item['ingredient_name'],
                category=item['category'],
                quantity=item['quantity'],
                unit=item['unit'],
                expiry_date=item['expiry_date'],
                added_date=item['added_date'],
                ingredient_id=item.get('ingredient_id')
            ))
        
        cursor.close()
        return inventory_items
    
    @staticmethod
    def get_by_id(item_id):
        conn = get_connection()
        cursor = conn.cursor(dictionary=True)
        
        cursor.execute("SELECT * FROM inventory WHERE id = %s", (item_id,))
        item = cursor.fetchone()
        cursor.close()
        
        if not item:
            return None
        
        return Inventory(
            id=item['id'],
            user_id=item['user_id'],
            ingredient_name=item['ingredient_name'],
            category=item['category'],
            quantity=item['quantity'],
            unit=item['unit'],
            expiry_date=item['expiry_date'],
            added_date=item['added_date'],
            ingredient_id=item.get('ingredient_id')
        )
    
    @staticmethod
    def get_ingredient_id(ingredient_name):
        """Get MongoDB ObjectID for an ingredient by name"""
        # Search for the ingredient in the recipes collection
        ingredient_name = ingredient_name.lower()
        results = mongo_db.recipes.aggregate([
            {"$unwind": "$ingredients"},
            {"$match": {"ingredients.name": ingredient_name}},
            {"$limit": 1}
        ])
        
        results_list = list(results)
        if results_list:
            # Return the MongoDB ObjectID as a string
            return str(results_list[0]['_id'])
        
        return None
    
    @staticmethod
    def get_ingredient_unit(ingredient_name):
        """Get standard unit for an ingredient by name"""
        ingredient_name = ingredient_name.lower()
        results = mongo_db.recipes.aggregate([
            {"$unwind": "$ingredients"},
            {"$match": {"ingredients.name": ingredient_name}},
            {"$limit": 1}
        ])
        
        results_list = list(results)
        if results_list:
            # Return the unit
            return results_list[0]['ingredients']['unit']
        
        return None
    
    @staticmethod
    def add_item(user_id, ingredient_name, category, quantity, unit, expiry_date=None):
        # First check if the ingredient exists in MongoDB
        ingredient_id = Inventory.get_ingredient_id(ingredient_name)
        
        if not ingredient_id:
            return None  # Ingredient not found in MongoDB
        
        conn = get_connection()
        cursor = conn.cursor()
        
        try:
            # Check if table has ingredient_id column
            cursor.execute("SHOW COLUMNS FROM inventory LIKE 'ingredient_id'")
            has_ingredient_id = cursor.fetchone() is not None
            
            if has_ingredient_id:
                cursor.execute(
                    """
                    INSERT INTO inventory 
                    (user_id, ingredient_name, category, quantity, unit, expiry_date, ingredient_id) 
                    VALUES (%s, %s, %s, %s, %s, %s, %s)
                    """,
                    (user_id, ingredient_name, category, quantity, unit, expiry_date, ingredient_id)
                )
            else:
                cursor.execute(
                    """
                    INSERT INTO inventory 
                    (user_id, ingredient_name, category, quantity, unit, expiry_date) 
                    VALUES (%s, %s, %s, %s, %s, %s)
                    """,
                    (user_id, ingredient_name, category, quantity, unit, expiry_date)
                )
                
            conn.commit()
            item_id = cursor.lastrowid
            cursor.close()
            
            return Inventory.get_by_id(item_id)
        except Exception as e:
            conn.rollback()
            cursor.close()
            print(f"Error adding inventory item: {e}")
            return None
    
    @staticmethod
    def update_item(item_id, ingredient_name, category, quantity, unit, expiry_date=None):
        # First check if the ingredient exists in MongoDB
        ingredient_id = Inventory.get_ingredient_id(ingredient_name)
        
        if not ingredient_id:
            return None  # Ingredient not found in MongoDB
            
        conn = get_connection()
        cursor = conn.cursor()
        
        try:
            # Check if table has ingredient_id column
            cursor.execute("SHOW COLUMNS FROM inventory LIKE 'ingredient_id'")
            has_ingredient_id = cursor.fetchone() is not None
            
            if has_ingredient_id:
                cursor.execute(
                    """
                    UPDATE inventory 
                    SET ingredient_name = %s, category = %s, quantity = %s, unit = %s, expiry_date = %s, ingredient_id = %s
                    WHERE id = %s
                    """,
                    (ingredient_name, category, quantity, unit, expiry_date, ingredient_id, item_id)
                )
            else:
                cursor.execute(
                    """
                    UPDATE inventory 
                    SET ingredient_name = %s, category = %s, quantity = %s, unit = %s, expiry_date = %s
                    WHERE id = %s
                    """,
                    (ingredient_name, category, quantity, unit, expiry_date, item_id)
                )
                
            conn.commit()
            cursor.close()
            
            return Inventory.get_by_id(item_id)
        except Exception as e:
            conn.rollback()
            cursor.close()
            print(f"Error updating inventory item: {e}")
            return None
    
    @staticmethod
    def delete_item(item_id):
        conn = get_connection()
        cursor = conn.cursor()
        
        try:
            cursor.execute("DELETE FROM inventory WHERE id = %s", (item_id,))
            conn.commit()
            cursor.close()
            return True
        except Exception as e:
            conn.rollback()
            cursor.close()
            print(f"Error deleting inventory item: {e}")
            return False
    
    @staticmethod
    def get_expiring_items(user_id):
        conn = get_connection()
        cursor = conn.cursor(dictionary=True)
        
        warning_date = datetime.now().date() + timedelta(days=Config.EXPIRATION_WARNING_DAYS)
        
        cursor.execute(
            """
            SELECT * FROM inventory 
            WHERE user_id = %s AND expiry_date IS NOT NULL AND expiry_date <= %s
            ORDER BY expiry_date
            """,
            (user_id, warning_date)
        )
        
        expiring_items = []
        for item in cursor.fetchall():
            expiring_items.append(Inventory(
                id=item['id'],
                user_id=item['user_id'],
                ingredient_name=item['ingredient_name'],
                category=item['category'],
                quantity=item['quantity'],
                unit=item['unit'],
                expiry_date=item['expiry_date'],
                added_date=item['added_date'],
                ingredient_id=item.get('ingredient_id')
            ))
        
        cursor.close()
        return expiring_items
    
    @staticmethod
    def update_quantity(user_id, ingredient_name, quantity_change):
        conn = get_connection()
        cursor = conn.cursor()
        
        try:
            # First check if the ingredient exists for this user
            cursor.execute(
                "SELECT id, quantity, unit FROM inventory WHERE user_id = %s AND ingredient_name = %s",
                (user_id, ingredient_name)
            )
            
            item = cursor.fetchone()
            
            if item:
                item_id, current_quantity, unit = item
                new_quantity = current_quantity + quantity_change
                
                # If new quantity is 0 or less, delete the item
                if new_quantity <= 0:
                    cursor.execute("DELETE FROM inventory WHERE id = %s", (item_id,))
                else:
                    cursor.execute(
                        "UPDATE inventory SET quantity = %s WHERE id = %s",
                        (new_quantity, item_id)
                    )
                
                conn.commit()
                cursor.close()
                return True
            else:
                cursor.close()
                return False
        except Exception as e:
            conn.rollback()
            cursor.close()
            print(f"Error updating inventory quantity: {e}")
            return False

    @staticmethod
    def convert_units(from_value, from_unit, to_unit):
        """
        Convert between compatible units
        This is a basic implementation - for a production app, this would be more comprehensive
        """
        # Basic conversions for demonstration
        mass_conversions = {
            'g': 1,
            'kg': 1000,
            'oz': 28.35,
            'lb': 453.59
        }
        
        volume_conversions = {
            'ml': 1,
            'l': 1000,
            'cups': 240,
            'tbsp': 15,
            'tsp': 5,
        }
        
        # Check if both units are in the same conversion group
        if from_unit in mass_conversions and to_unit in mass_conversions:
            # Convert to base unit (g) and then to target unit
            base_value = from_value * mass_conversions[from_unit]
            return base_value / mass_conversions[to_unit]
        
        elif from_unit in volume_conversions and to_unit in volume_conversions:
            # Convert to base unit (ml) and then to target unit
            base_value = from_value * volume_conversions[from_unit]
            return base_value / volume_conversions[to_unit]
        
        # If units are not compatible or not in our conversion tables, return None
        return None

...............................................

from flask import Blueprint, render_template, redirect, url_for, request, flash, jsonify
from flask_login import login_required, current_user
from models.inventory import Inventory
from datetime import datetime
from flask_wtf import FlaskForm
from wtforms import StringField, FloatField, SelectField, DateField, SubmitField
from wtforms.validators import DataRequired, Optional
from database.mongo_setup import mongo_db

inventory_bp = Blueprint('inventory', __name__, url_prefix='/inventory')

# Categories for the form dropdown
CATEGORIES = [
    ('vegetable', 'Vegetable'),
    ('fruit', 'Fruit'),
    ('meat', 'Meat'),
    ('dairy', 'Dairy'),
    ('grain', 'Grain'),
    ('spice', 'Spice'),
    ('condiment', 'Condiment'),
    ('bakery', 'Bakery'),
    ('canned goods', 'Canned Goods'),
    ('frozen', 'Frozen'),
    ('beverage', 'Beverage'),
    ('snack', 'Snack'),
    ('other', 'Other')
]

# Units for the form dropdown
UNITS = [
    ('g', 'Grams (g)'),
    ('kg', 'Kilograms (kg)'),
    ('ml', 'Milliliters (ml)'),
    ('l', 'Liters (l)'),
    ('cups', 'Cups'),
    ('tbsp', 'Tablespoons'),
    ('tsp', 'Teaspoons'),
    ('whole', 'Whole'),
    ('slices', 'Slices'),
    ('pieces', 'Pieces'),
    ('pinch', 'Pinch'),
    ('oz', 'Ounces (oz)'),
    ('lb', 'Pounds (lb)'),
    ('cloves', 'Cloves')
]

class InventoryForm(FlaskForm):
    ingredient_name = StringField('Ingredient Name', validators=[DataRequired()])
    category = SelectField('Category', choices=CATEGORIES, validators=[DataRequired()])
    quantity = FloatField('Quantity', validators=[DataRequired()])
    unit = SelectField('Unit', choices=UNITS, validators=[DataRequired()])
    expiry_date = DateField('Expiry Date (Optional)', format='%Y-%m-%d', validators=[Optional()])
    submit = SubmitField('Save')

@inventory_bp.route('/')
@login_required
def index():
    inventory_items = Inventory.get_by_user_id(current_user.id)
    expiring_items = Inventory.get_expiring_items(current_user.id)
    return render_template('inventory/index.html', 
                          inventory_items=inventory_items, 
                          expiring_items=expiring_items,
                          categories=CATEGORIES,
                          datetime=datetime)

@inventory_bp.route('/add', methods=['GET', 'POST'])
@login_required
def add():
    form = InventoryForm()
    
    if form.validate_on_submit():
        ingredient_name = form.ingredient_name.data.lower()
        
        # Validate that ingredient exists in MongoDB
        ingredient_id = Inventory.get_ingredient_id(ingredient_name)
        if not ingredient_id:
            flash('This ingredient is not in our database. Please check the spelling or try another ingredient.', 'danger')
            return render_template('inventory/add.html', form=form, title="Add Ingredient")
        
        item = Inventory.add_item(
            user_id=current_user.id,
            ingredient_name=ingredient_name,
            category=form.category.data,
            quantity=form.quantity.data,
            unit=form.unit.data,
            expiry_date=form.expiry_date.data
        )
        
        if item:
            flash('Ingredient added to inventory!', 'success')
            return redirect(url_for('inventory.index'))
        else:
            flash('Error adding ingredient. Please try again.', 'danger')
    
    return render_template('inventory/add.html', form=form, title="Add Ingredient")

@inventory_bp.route('/edit/<int:item_id>', methods=['GET', 'POST'])
@login_required
def edit(item_id):
    item = Inventory.get_by_id(item_id)
    
    if not item or item.user_id != current_user.id:
        flash('Item not found or you do not have permission to edit it.', 'danger')
        return redirect(url_for('inventory.index'))
    
    form = InventoryForm()
    
    if form.validate_on_submit():
        ingredient_name = form.ingredient_name.data.lower()
        
        # Validate that ingredient exists in MongoDB
        ingredient_id = Inventory.get_ingredient_id(ingredient_name)
        if not ingredient_id:
            flash('This ingredient is not in our database. Please check the spelling or try another ingredient.', 'danger')
            return render_template('inventory/edit.html', form=form, item=item, title="Edit Ingredient")
            
        updated_item = Inventory.update_item(
            item_id=item_id,
            ingredient_name=ingredient_name,
            category=form.category.data,
            quantity=form.quantity.data,
            unit=form.unit.data,
            expiry_date=form.expiry_date.data
        )
        
        if updated_item:
            flash('Ingredient updated successfully!', 'success')
            return redirect(url_for('inventory.index'))
        else:
            flash('Error updating ingredient. Please try again.', 'danger')
    
    # Pre-fill form
    if request.method == 'GET':
        form.ingredient_name.data = item.ingredient_name
        form.category.data = item.category
        form.quantity.data = item.quantity
        form.unit.data = item.unit
        form.expiry_date.data = item.expiry_date
    
    return render_template('inventory/edit.html', form=form, item=item, title="Edit Ingredient")

@inventory_bp.route('/delete/<int:item_id>', methods=['POST'])
@login_required
def delete(item_id):
    item = Inventory.get_by_id(item_id)
    
    if not item or item.user_id != current_user.id:
        flash('Item not found or you do not have permission to delete it.', 'danger')
        return redirect(url_for('inventory.index'))
    
    if Inventory.delete_item(item_id):
        flash('Ingredient removed from inventory!', 'success')
    else:
        flash('Error removing ingredient. Please try again.', 'danger')
    
    return redirect(url_for('inventory.index'))

@inventory_bp.route('/api/items', methods=['GET'])
@login_required
def api_get_items():
    inventory_items = Inventory.get_by_user_id(current_user.id)
    items_list = []
    
    for item in inventory_items:
        items_list.append({
            'id': item.id,
            'ingredient_name': item.ingredient_name,
            'category': item.category,
            'quantity': item.quantity,
            'unit': item.unit,
            'expiry_date': item.expiry_date.isoformat() if item.expiry_date else None
        })
    
    return jsonify({'items': items_list})

@inventory_bp.route('/api/ingredients', methods=['GET'])
@login_required
def api_get_ingredients():
    search_term = request.args.get('term', '').lower()
    
    # Get ingredients from MongoDB
    # Create a list of unique ingredients
    unique_ingredients = []
    
    # Get ingredients from recipes collection
    pipeline = [
        {"$unwind": "$ingredients"},
        {"$group": {
            "_id": "$ingredients.name",
            "unit": {"$first": "$ingredients.unit"}
        }},
        {"$sort": {"_id": 1}}
    ]
    
    if search_term:
        pipeline.insert(1, {"$match": {"ingredients.name": {"$regex": f"^{search_term}"}}})
    
    ingredients = mongo_db.recipes.aggregate(pipeline)
    
    for ingredient in ingredients:
        unique_ingredients.append({
            'name': ingredient['_id'],
            'unit': ingredient['unit']
        })
    
    return jsonify({'ingredients': unique_ingredients})

..,............................


from flask import Blueprint, render_template, redirect, url_for, request, flash
from flask_login import login_user, logout_user, login_required, current_user
from models.user import User
from datetime import datetime
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, EmailField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Email, Length, EqualTo
from database.mysql_setup import get_connection
import bcrypt

auth_bp = Blueprint('auth', __name__, url_prefix='/auth')

class LoginForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired()])
    remember = BooleanField('Remember Me')
    submit = SubmitField('Log In')

class RegisterForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired(), Length(min=3, max=20)])
    email = EmailField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Password', validators=[DataRequired(), Length(min=6)])
    confirm_password = PasswordField('Confirm Password', validators=[DataRequired(), EqualTo('password')])
    submit = SubmitField('Create Account')

@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    # If user is already logged in, redirect to dashboard
    if current_user.is_authenticated:
        return redirect(url_for('recipe.index'))
    
    form = LoginForm()
    
    if form.validate_on_submit():
        username = form.username.data
        password = form.password.data
        
        user = User.get_by_username(username)
        
        if user and bcrypt.checkpw(password.encode('utf-8'), user.password.encode('utf-8')):
            login_user(user, remember=form.remember.data)
            next_page = request.args.get('next')
            return redirect(next_page if next_page else url_for('recipe.index'))
        else:
            flash('Login failed. Please check your username and password.', 'danger')
    
    return render_template('auth/login.html', form=form)

@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    # If user is already logged in, redirect to dashboard
    if current_user.is_authenticated:
        return redirect(url_for('recipe.index'))
    
    form = RegisterForm()
    
    if form.validate_on_submit():
        username = form.username.data
        email = form.email.data
        password = form.password.data
        
        # Check if username already exists
        if User.get_by_username(username):
            flash('Username already exists. Please choose a different username.', 'danger')
            return render_template('auth/register.html', form=form)
        
        # Check if email already exists
        if User.get_by_email(email):
            flash('Email already registered. Please use a different email.', 'danger')
            return render_template('auth/register.html', form=form)
        
        # Create new user
        user = User.create(username, email, password)
        
        if user:
            flash('Account created successfully! Please log in.', 'success')
            return redirect(url_for('auth.login'))
        else:
            flash('Error creating account. Please try again.', 'danger')
    
    return render_template('auth/register.html', form=form)

@auth_bp.route('/logout')
@login_required
def logout():
    logout_user()
    flash('You have been logged out.', 'success')
    return redirect(url_for('auth.login'))

@auth_bp.route('/profile')
@login_required
def profile():
    # Get user preferences
    conn = get_connection()
    cursor = conn.cursor(dictionary=True)
    
    # Get user preferences
    cursor.execute("SELECT * FROM user_preferences WHERE user_id = %s", (current_user.id,))
    preferences = cursor.fetchone()
    
    # Get user registration date
    cursor.execute("SELECT created_at FROM users WHERE id = %s", (current_user.id,))
    user_data = cursor.fetchone()
    cursor.close()
    
    member_since = user_data.get('created_at') if user_data else datetime.now()
    
    return render_template('auth/profile.html', 
                          preferences=preferences,
                          member_since=member_since)

@auth_bp.route('/update_preferences', methods=['POST'])
@login_required
def update_preferences():
    vegetarian = request.form.get('vegetarian') == 'on'
    vegan = request.form.get('vegan') == 'on'
    gluten_free = request.form.get('gluten_free') == 'on'
    dairy_free = request.form.get('dairy_free') == 'on'
    
    conn = get_connection()
    cursor = conn.cursor()
    
    try:
        # Check if preferences exist
        cursor.execute("SELECT id FROM user_preferences WHERE user_id = %s", (current_user.id,))
        preferences = cursor.fetchone()
        
        if preferences:
            # Update existing preferences
            cursor.execute(
                """
                UPDATE user_preferences 
                SET is_vegetarian = %s, is_vegan = %s, is_gluten_free = %s, is_dairy_free = %s
                WHERE user_id = %s
                """,
                (vegetarian, vegan, gluten_free, dairy_free, current_user.id)
            )
        else:
            # Create new preferences
            cursor.execute(
                """
                INSERT INTO user_preferences 
                (user_id, is_vegetarian, is_vegan, is_gluten_free, is_dairy_free)
                VALUES (%s, %s, %s, %s, %s)
                """,
                (current_user.id, vegetarian, vegan, gluten_free, dairy_free)
            )
            
        conn.commit()
        flash('Your dietary preferences have been updated.', 'success')
    except Exception as e:
        conn.rollback()
        flash(f'An error occurred: {e}', 'danger')
    finally:
        cursor.close()
    
    return redirect(url_for('auth.profile'))

@auth_bp.route('/change_password', methods=['GET', 'POST'])
@login_required
def change_password():
    if request.method == 'POST':
        current_password = request.form.get('current_password')
        new_password = request.form.get('new_password')
        confirm_password = request.form.get('confirm_password')
        
        # Get current user with password
        conn = get_connection()
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT password FROM users WHERE id = %s", (current_user.id,))
        user_data = cursor.fetchone()
        cursor.close()
        
        if not user_data:
            flash('User not found.', 'danger')
            return redirect(url_for('auth.profile'))
        
        # Verify current password
        if not bcrypt.checkpw(current_password.encode('utf-8'), user_data['password'].encode('utf-8')):
            flash('Current password is incorrect.', 'danger')
            return render_template('auth/change_password.html')
        
        # Validate new password
        if new_password != confirm_password:
            flash('New passwords do not match.', 'danger')
            return render_template('auth/change_password.html')
        
        if len(new_password) < 6:
            flash('New password must be at least 6 characters long.', 'danger')
            return render_template('auth/change_password.html')
        
        # Update password
        conn = get_connection()
        cursor = conn.cursor()
        
        try:
            hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt())
            cursor.execute(
                "UPDATE users SET password = %s WHERE id = %s",
                (hashed_password.decode('utf-8'), current_user.id)
            )
            conn.commit()
            flash('Your password has been updated.', 'success')
            return redirect(url_for('auth.profile'))
        except Exception as e:
            conn.rollback()
            flash(f'An error occurred: {e}', 'danger')
        finally:
            cursor.close()
    
    return render_template('auth/change_password.html')

@auth_bp.route('/delete_account', methods=['GET', 'POST'])
@login_required
def delete_account():
    if request.method == 'POST':
        password = request.form.get('password')
        
        # Get current user with password
        conn = get_connection()
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT password FROM users WHERE id = %s", (current_user.id,))
        user_data = cursor.fetchone()
        
        if not user_data:
            flash('User not found.', 'danger')
            return redirect(url_for('auth.profile'))
        
        # Verify password
        if not bcrypt.checkpw(password.encode('utf-8'), user_data['password'].encode('utf-8')):
            flash('Password is incorrect.', 'danger')
            return render_template('auth/delete_account.html')
        
        # Delete user account (all related data will be deleted due to foreign key constraints)
        try:
            cursor.execute("DELETE FROM users WHERE id = %s", (current_user.id,))
            conn.commit()
            logout_user()
            flash('Your account has been deleted.', 'success')
            return redirect(url_for('index'))
        except Exception as e:
            conn.rollback()
            flash(f'An error occurred: {e}', 'danger')
        finally:
            cursor.close()
    
    return render_template('auth/delete_account.html')

.....................


from flask import Blueprint, render_template, redirect, url_for, request, flash, session
from flask_login import login_required, current_user
from models.recipe import Recipe
from models.inventory import Inventory
from models.completed_recipe import CompletedRecipe
from database.mysql_setup import get_connection

recipe_bp = Blueprint('recipe', __name__, url_prefix='/recipe')

@recipe_bp.route('/')
@login_required
def index():
    recipes = Recipe.get_all()
    return render_template('recipe/index.html', recipes=recipes)

@recipe_bp.route('/<recipe_id>')
@login_required
def detail(recipe_id):
    recipe = Recipe.get_by_id(recipe_id)
    
    if not recipe:
        flash('Recipe not found.', 'danger')
        return redirect(url_for('recipe.index'))
    
    # Get user's inventory items for matching
    inventory_items = Inventory.get_by_user_id(current_user.id)
    
    # Create a list of ingredient names the user has
    user_ingredients = [item.ingredient_name.lower() for item in inventory_items]
    
    # Check which recipe ingredients the user has
    inventory_match = []
    missing_ingredients = []
    
    for ingredient in recipe.get('ingredients', []):
        ingredient_name = ingredient.get('name', '').lower()
        ingredient_amount = ingredient.get('amount', 0)
        ingredient_unit = ingredient.get('unit', '')
        
        # Check if user has this ingredient
        if ingredient_name in user_ingredients:
            # Find the inventory item
            inventory_item = next((item for item in inventory_items if item.ingredient_name.lower() == ingredient_name), None)
            
            if inventory_item:
                # Check if units are compatible
                if inventory_item.unit == ingredient_unit:
                    # Direct comparison
                    has_enough = inventory_item.quantity >= ingredient_amount
                else:
                    # Try to convert
                    converted_amount = Inventory.convert_units(ingredient_amount, ingredient_unit, inventory_item.unit)
                    
                    if converted_amount is not None:
                        has_enough = inventory_item.quantity >= converted_amount
                    else:
                        # Can't compare units, assume user has it
                        has_enough = True
                
                inventory_match.append({
                    'name': ingredient_name,
                    'has': True,
                    'has_enough': has_enough,
                    'quantity': inventory_item.quantity,
                    'unit': inventory_item.unit,
                    'needs': ingredient_amount,
                    'needs_unit': ingredient_unit
                })
            else:
                # This shouldn't happen, but just in case
                missing_ingredients.append(ingredient)
        else:
            missing_ingredients.append(ingredient)
            inventory_match.append({
                'name': ingredient_name,
                'has': False,
                'has_enough': False,
                'quantity': 0,
                'unit': '',
                'needs': ingredient_amount,
                'needs_unit': ingredient_unit
            })
    
    # Check if user has completed this recipe before
    completed_recipes = CompletedRecipe.get_by_user_recipe(current_user.id, recipe_id)
    
    return render_template('recipe/detail.html', 
                          recipe=recipe, 
                          inventory_match=inventory_match,
                          missing_ingredients=missing_ingredients,
                          completed_recipes=completed_recipes)

@recipe_bp.route('/search', methods=['GET', 'POST'])
@login_required
def search():
    search_term = request.args.get('term', '')
    
    # Get all filter parameters
    vegetarian = request.args.get('vegetarian') == 'on'
    vegan = request.args.get('vegan') == 'on'
    gluten_free = request.args.get('gluten_free') == 'on'
    dairy_free = request.args.get('dairy_free') == 'on'
    
    # Time filter
    max_time = request.args.get('max_time')
    if max_time and max_time.isdigit():
        max_time = int(max_time)
    else:
        max_time = None
    
    # Difficulty filter
    difficulty = request.args.get('difficulty')
    if difficulty not in ['Easy', 'Medium', 'Hard']:
        difficulty = None
    
    if search_term:
        recipes = Recipe.search_by_name(search_term)
    else:
        recipes = Recipe.get_all()
    
    # Create dietary filters dict
    dietary_filters = {}
    if vegetarian:
        dietary_filters['vegetarian'] = True
    if vegan:
        dietary_filters['vegan'] = True
    if gluten_free:
        dietary_filters['gluten_free'] = True
    if dairy_free:
        dietary_filters['dairy_free'] = True
    
    # Apply dietary filters if any are selected
    if dietary_filters:
        recipes = Recipe.filter_by_dietary(recipes, dietary_filters)
    
    # Apply time filter
    if max_time:
        recipes = Recipe.filter_by_time(recipes, max_time)
    
    # Apply difficulty filter
    if difficulty:
        recipes = Recipe.filter_by_difficulty(recipes, difficulty)
    
    # Get user's dietary preferences for filter defaults
    conn = get_connection()
    cursor = conn.cursor(dictionary=True)
    cursor.execute("SELECT * FROM user_preferences WHERE user_id = %s", (current_user.id,))
    preferences = cursor.fetchone()
    cursor.close()
    
    return render_template('recipe/search.html', 
                          recipes=recipes, 
                          search_term=search_term,
                          preferences=preferences,
                          max_time=max_time,
                          difficulty=difficulty)

@recipe_bp.route('/completed/<recipe_id>', methods=['POST'])
@login_required
def mark_completed(recipe_id):
    recipe = Recipe.get_by_id(recipe_id)
    
    if not recipe:
        flash('Recipe not found.', 'danger')
        return redirect(url_for('recipe.index'))
    
    servings = int(request.form.get('servings', 1))
    
    # Add to completed recipes
    completed = CompletedRecipe.add(current_user.id, recipe_id, servings)
    
    if completed:
        # Subtract used ingredients from inventory
        for ingredient in recipe.get('ingredients', []):
            ingredient_name = ingredient.get('name', '').lower()
            ingredient_amount = ingredient.get('amount', 0) * servings
            ingredient_unit = ingredient.get('unit', '')
            
            # Update inventory
            Inventory.update_quantity(current_user.id, ingredient_name, -ingredient_amount)
        
        flash('Recipe marked as completed!', 'success')
    else:
        flash('Error marking recipe as completed.', 'danger')
    
    return redirect(url_for('recipe.detail', recipe_id=recipe_id))

@recipe_bp.route('/completed')
@login_required
def completed():
    completed_recipes = CompletedRecipe.get_by_user_id(current_user.id)
    
    recipes = []
    for completed in completed_recipes:
        recipe = Recipe.get_by_id(completed.recipe_id)
        if recipe:
            recipes.append({
                'recipe': recipe,
                'completed_date': completed.completed_date,
                'servings': completed.servings_made
            })
    
    return render_template('recipe/completed.html', recipes=recipes)

...................................

from flask import Blueprint, render_template, redirect, url_for, request, flash, jsonify
from flask_login import login_required, current_user
from models.meal_plan import MealPlan
from models.recipe import Recipe
from models.inventory import Inventory
from datetime import datetime, timedelta

meal_plan_bp = Blueprint('meal_plan', __name__, url_prefix='/meal-plan')

# Define days of the week
days_of_week = [
    {'id': 0, 'name': 'Monday'},
    {'id': 1, 'name': 'Tuesday'},
    {'id': 2, 'name': 'Wednesday'},
    {'id': 3, 'name': 'Thursday'},
    {'id': 4, 'name': 'Friday'},
    {'id': 5, 'name': 'Saturday'},
    {'id': 6, 'name': 'Sunday'}
]

# Define meal types
meal_types = [
    {'id': 'breakfast', 'name': 'Breakfast'},
    {'id': 'lunch', 'name': 'Lunch'},
    {'id': 'dinner', 'name': 'Dinner'},
    {'id': 'snack', 'name': 'Snack'}
]

@meal_plan_bp.route('/')
@login_required
def index():
    # Get the current week's date range
    today = datetime.now().date()
    monday = today - timedelta(days=today.weekday())
    
    # Get or create meal plan for this week
    meal_plan = MealPlan.get_by_week(current_user.id, monday)
    
    if not meal_plan:
        meal_plan = MealPlan.create(current_user.id, monday)
    
    # Get meal plan items
    meal_plan_items = MealPlan.get_items(meal_plan.id)
    
    # Organize items by day and meal type
    meal_schedule = {}
    
    # Initialize empty meal schedule
    for day in days_of_week:
        meal_schedule[day['id']] = {}
        for meal_type in meal_types:
            meal_schedule[day['id']][meal_type['id']] = None
    
    # Fill in scheduled meals
    for item in meal_plan_items:
        recipe = Recipe.get_by_id(item.recipe_id)
        if recipe:
            meal_schedule[item.day_of_week][item.meal_type] = {
                'recipe': recipe,
                'id': item.id
            }
    
    return render_template('meal_plan/index.html',
                          meal_plan=meal_plan,
                          days_of_week=days_of_week,
                          meal_types=meal_types,
                          meal_schedule=meal_schedule)

@meal_plan_bp.route('/add/<recipe_id>', methods=['POST'])
@login_required
def add_recipe(recipe_id):
    day_of_week = int(request.form.get('day_of_week', 0))
    meal_type = request.form.get('meal_type', 'dinner')
    
    # Get the current week's date range
    today = datetime.now().date()
    monday = today - timedelta(days=today.weekday())
    
    # Get or create meal plan for this week
    meal_plan = MealPlan.get_by_week(current_user.id, monday)
    
    if not meal_plan:
        meal_plan = MealPlan.create(current_user.id, monday)
    
    # Check if a meal is already scheduled for this slot
    existing_item = MealPlan.get_item_by_day_meal(meal_plan.id, day_of_week, meal_type)
    
    if existing_item:
        # Update existing item
        MealPlan.update_item(existing_item.id, recipe_id)
        flash('Meal plan updated!', 'success')
    else:
        # Add new item
        MealPlan.add_item(meal_plan.id, recipe_id, day_of_week, meal_type)
        flash('Recipe added to meal plan!', 'success')
    
    return redirect(url_for('meal_plan.index'))

@meal_plan_bp.route('/remove/<int:item_id>', methods=['POST'])
@login_required
def remove_recipe(item_id):
    # Remove item from meal plan
    if MealPlan.remove_item(item_id):
        flash('Recipe removed from meal plan!', 'success')
    else:
        flash('Error removing recipe from meal plan.', 'danger')
    
    return redirect(url_for('meal_plan.index'))

@meal_plan_bp.route('/api/suggest', methods=['GET'])
@login_required
def api_suggest_recipes():
    # Get user's inventory
    inventory_items = Inventory.get_by_user_id(current_user.id)
    
    # Get ingredients user has
    ingredients = [item.ingredient_name.lower() for item in inventory_items]
    
    # Get recipes matching user's ingredients
    recipes = Recipe.search_by_ingredients(ingredients)
    
    # Get user's dietary preferences
    # TODO: Implement
    
    # Return top suggestions
    suggestions = []
    for recipe in recipes[:5]:  # Top 5 recipes
        suggestions.append({
            'id': str(recipe['_id']),
            'name': recipe['name'],
            'match_percentage': recipe.get('match_percentage', 0),
            'total_time': recipe.get('prep_time', 0) + recipe.get('cook_time', 0)
        })
    
    return jsonify({'suggestions': suggestions})

@meal_plan_bp.route('/grocery-list')
@login_required
def grocery_list():
    # Get the current week's date range
    today = datetime.now().date()
    monday = today - timedelta(days=today.weekday())
    
    # Get meal plan for this week
    meal_plan = MealPlan.get_by_week(current_user.id, monday)
    
    if not meal_plan:
        flash('No meal plan found for this week.', 'info')
        return redirect(url_for('meal_plan.index'))
    
    # Get meal plan items
    meal_plan_items = MealPlan.get_items(meal_plan.id)
    
    # Get ingredients needed
    ingredients_needed = {}
    
    for item in meal_plan_items:
        recipe = Recipe.get_by_id(item.recipe_id)
        if recipe:
            for ingredient in recipe.get('ingredients', []):
                name = ingredient.get('name', '').lower()
                amount = ingredient.get('amount', 0)
                unit = ingredient.get('unit', '')
                
                # Add to ingredients needed
                if name in ingredients_needed:
                    if ingredients_needed[name]['unit'] == unit:
                        ingredients_needed[name]['amount'] += amount
                    else:
                        # Different units, keep separate
                        alt_key = f"{name} ({unit})"
                        if alt_key in ingredients_needed:
                            ingredients_needed[alt_key]['amount'] += amount
                        else:
                            ingredients_needed[alt_key] = {
                                'name': name,
                                'amount': amount,
                                'unit': unit
                            }
                else:
                    ingredients_needed[name] = {
                        'name': name,
                        'amount': amount,
                        'unit': unit
                    }
    
    # Check user's inventory for items already owned
    inventory_items = Inventory.get_by_user_id(current_user.id)
    
    for item in inventory_items:
        name = item.ingredient_name.lower()
        
        if name in ingredients_needed:
            # Check if units match
            if item.unit == ingredients_needed[name]['unit']:
                # Subtract inventory amount
                ingredients_needed[name]['amount'] -= item.quantity
                
                # If user has enough, remove from grocery list
                if ingredients_needed[name]['amount'] <= 0:
                    ingredients_needed[name]['in_inventory'] = True
                    ingredients_needed[name]['amount'] = 0
                else:
                    ingredients_needed[name]['in_inventory'] = False
            else:
                # Try to convert units
                converted_amount = Inventory.convert_units(
                    item.quantity, 
                    item.unit, 
                    ingredients_needed[name]['unit']
                )
                
                if converted_amount is not None:
                    # Subtract converted amount
                    ingredients_needed[name]['amount'] -= converted_amount
                    
                    # If user has enough, remove from grocery list
                    if ingredients_needed[name]['amount'] <= 0:
                        ingredients_needed[name]['in_inventory'] = True
                        ingredients_needed[name]['amount'] = 0
                    else:
                        ingredients_needed[name]['in_inventory'] = False
                else:
                    # Can't convert, mark as maybe
                    ingredients_needed[name]['in_inventory'] = 'maybe'
        else:
            # Check alternate keys (different units)
            for key in ingredients_needed:
                if key.startswith(name + ' ('):
                    ingredients_needed[key]['in_inventory'] = 'maybe'
    
    # Convert to list for template
    grocery_list = list(ingredients_needed.values())
    
    # Group by "department" (category)
    categories = {}
    
    for ingredient in grocery_list:
        # Skip items user already has enough of
        if ingredient.get('in_inventory', False) is True:
            continue
        
        # Get category from inventory item if exists
        category = 'Other'
        for item in inventory_items:
            if item.ingredient_name.lower() == ingredient['name'].lower():
                category = item.category
                break
        
        if category not in categories:
            categories[category] = []
        
        categories[category].append(ingredient)
    
    return render_template('meal_plan/grocery_list.html',
                          meal_plan=meal_plan,
                          categories=categories,
                          grocery_list=grocery_list)

@meal_plan_bp.route('/auto-generate', methods=['POST'])
@login_required
def auto_generate():
    # Get user's inventory
    inventory_items = Inventory.get_by_user_id(current_user.id)
    
    # Get ingredients user has
    ingredients = [item.ingredient_name.lower() for item in inventory_items]
    
    # Get recipes matching user's ingredients
    recipes = Recipe.search_by_ingredients(ingredients)
    
    # Get user's dietary preferences
    conn = get_connection()
    cursor = conn.cursor(dictionary=True)
    cursor.execute("SELECT * FROM user_preferences WHERE user_id = %s", (current_user.id,))
    preferences = cursor.fetchone()
    cursor.close()
    
    # Filter by dietary restrictions if needed
    if preferences:
        dietary_filters = {}
        if preferences.get('is_vegetarian'):
            dietary_filters['vegetarian'] = True
        if preferences.get('is_vegan'):
            dietary_filters['vegan'] = True
        if preferences.get('is_gluten_free'):
            dietary_filters['gluten_free'] = True
        if preferences.get('is_dairy_free'):
            dietary_filters['dairy_free'] = True
        
        if dietary_filters:
            recipes = Recipe.filter_by_dietary(recipes, dietary_filters)
    
    # Get the current week's date range
    today = datetime.now().date()
    monday = today - timedelta(days=today.weekday())
    
    # Get or create meal plan for this week
    meal_plan = MealPlan.get_by_week(current_user.id, monday)
    
    if not meal_plan:
        meal_plan = MealPlan.create(current_user.id, monday)
    
    # Auto-generate meal plan
    # This is a basic implementation - could be improved with more advanced algorithms
    
    # Clear current meal plan
    MealPlan.clear(meal_plan.id)
    
    # Assign recipes to meal slots
    recipe_index = 0
    recipes_assigned = 0
    
    # We'll assign dinners first
    for day in range(7):
        if recipe_index < len(recipes):
            MealPlan.add_item(meal_plan.id, str(recipes[recipe_index]['_id']), day, 'dinner')
            recipe_index += 1
            recipes_assigned += 1
    
    # Then lunches
    for day in range(7):
        if recipe_index < len(recipes):
            MealPlan.add_item(meal_plan.id, str(recipes[recipe_index]['_id']), day, 'lunch')
            recipe_index += 1
            recipes_assigned += 1
    
    # Then breakfasts
    for day in range(7):
        if recipe_index < len(recipes):
            MealPlan.add_item(meal_plan.id, str(recipes[recipe_index]['_id']), day, 'breakfast')
            recipe_index += 1
            recipes_assigned += 1
    
    if recipes_assigned > 0:
        flash(f'Auto-generated meal plan with {recipes_assigned} recipes!', 'success')
    else:
        flash('Could not auto-generate meal plan. Please add more ingredients to your inventory.', 'warning')
    
    return redirect(url_for('meal_plan.index'))

............................................

{% extends "base.html" %}

{% block title %}CookBookIt - My Profile{% endblock %}

{% block content %}
<div class="slide-in-up">
    <h1 class="mb-4">My Profile</h1>
    
    <div class="row">
        <div class="col-md-6 mb-4">
            <div class="card">
                <div class="card-body">
                    <h2 class="card-title mb-3">User Information</h2>
                    <p><strong>Username:</strong> {{ current_user.username }}</p>
                    <p><strong>Email:</strong> {{ current_user.email }}</p>
                    <p><strong>Member since:</strong> {{ member_since.strftime('%B %d, %Y') }}</p>
                </div>
            </div>
        </div>
        
        <div class="col-md-6 mb-4">
            <div class="card">
                <div class="card-body">
                    <h2 class="card-title mb-3">Dietary Preferences</h2>
                    
                    <form method="POST" action="{{ url_for('auth.update_preferences') }}">
                        <div class="form-group">
                            <div>
                                <input type="checkbox" id="vegetarian" name="vegetarian" class="mr-2"
                                      {% if preferences and preferences.is_vegetarian %}checked{% endif %}>
                                <label for="vegetarian">Vegetarian</label>
                            </div>
                            <div>
                                <input type="checkbox" id="vegan" name="vegan" class="mr-2"
                                      {% if preferences and preferences.is_vegan %}checked{% endif %}>
                                <label for="vegan">Vegan</label>
                            </div>
                            <div>
                                <input type="checkbox" id="gluten_free" name="gluten_free" class="mr-2"
                                      {% if preferences and preferences.is_gluten_free %}checked{% endif %}>
                                <label for="gluten_free">Gluten Free</label>
                            </div>
                            <div>
                                <input type="checkbox" id="dairy_free" name="dairy_free" class="mr-2"
                                      {% if preferences and preferences.is_dairy_free %}checked{% endif %}>
                                <label for="dairy_free">Dairy Free</label>
                            </div>
                        </div>
                        
                        <button type="submit" class="btn btn-primary mt-3">Update Preferences</button>
                    </form>
                </div>
            </div>
        </div>
    </div>
    
    <div class="card mb-4">
        <div class="card-body">
            <h2 class="card-title mb-3">Account Settings</h2>
            <div class="mt-3">
                <a href="{{ url_for('auth.change_password') }}" class="btn btn-outline">Change Password</a>
                <a href="{{ url_for('auth.delete_account') }}" class="btn btn-danger" onclick="return confirm('Are you sure you want to delete your account? This cannot be undone.')">Delete Account</a>
            </div>
        </div>
    </div>
</div>
{% endblock %}

...................................


{% extends "base.html" %}

{% block title %}CookBookIt - Change Password{% endblock %}

{% block content %}
<div class="slide-in-up">
    <h1 class="mb-4">Change Password</h1>
    
    <div class="card">
        <div class="card-body">
            <form method="POST" action="{{ url_for('auth.change_password') }}">
                <div class="form-group">
                    <label class="form-label" for="current_password">Current Password</label>
                    <input type="password" id="current_password" name="current_password" class="form-control" required>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="new_password">New Password</label>
                    <input type="password" id="new_password" name="new_password" class="form-control" required minlength="6">
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="confirm_password">Confirm New Password</label>
                    <input type="password" id="confirm_password" name="confirm_password" class="form-control" required minlength="6">
                </div>
                
                <div class="d-flex justify-content-between mt-4">
                    <a href="{{ url_for('auth.profile') }}" class="btn btn-outline">Cancel</a>
                    <button type="submit" class="btn btn-primary">Update Password</button>
                </div>
            </form>
        </div>
    </div>
</div>
{% endblock %}

.............................................


{% extends "base.html" %}

{% block title %}CookBookIt - Delete Account{% endblock %}

{% block content %}
<div class="slide-in-up">
    <h1 class="mb-4">Delete Account</h1>
    
    <div class="card">
        <div class="card-body">
            <div class="alert alert-danger">
                <h4>Warning!</h4>
                <p>This action cannot be undone. All your data, including inventory, meal plans, and completed recipes, will be permanently deleted.</p>
            </div>
            
            <form method="POST" action="{{ url_for('auth.delete_account') }}">
                <div class="form-group">
                    <label class="form-label" for="password">Enter your password to confirm</label>
                    <input type="password" id="password" name="password" class="form-control" required>
                </div>
                
                <div class="d-flex justify-content-between mt-4">
                    <a href="{{ url_for('auth.profile') }}" class="btn btn-outline">Cancel</a>
                    <button type="submit" class="btn btn-danger">Delete My Account</button>
                </div>
            </form>
        </div>
    </div>
</div>
{% endblock %}


.....,.........................
{% extends "base.html" %}

{% block title %}CookBookIt - Add Ingredient{% endblock %}

{% block content %}
<div class="slide-in-up">
    <h1 class="mb-4">{{ title }}</h1>
    
    <div class="card">
        <div class="card-body">
            <form method="POST">
                {{ form.hidden_tag() }}
                
                <div class="form-group">
                    {{ form.ingredient_name.label(class="form-label") }}
                    {{ form.ingredient_name(class="form-control", id="ingredient-name-input", autocomplete="off") }}
                    <div id="ingredient-suggestions" class="ingredient-suggestions"></div>
                    {% if form.ingredient_name.errors %}
                        {% for error in form.ingredient_name.errors %}
                            <span class="text-danger">{{ error }}</span>
                        {% endfor %}
                    {% endif %}
                </div>
                
                <div class="form-group">
                    {{ form.category.label(class="form-label") }}
                    {{ form.category(class="form-select") }}
                    {% if form.category.errors %}
                        {% for error in form.category.errors %}
                            <span class="text-danger">{{ error }}</span>
                        {% endfor %}
                    {% endif %}
                </div>
                
                <div class="d-flex gap-3">
                    <div class="form-group" style="flex: 1;">
                        {{ form.quantity.label(class="form-label") }}
                        {{ form.quantity(class="form-control", min="0.01", step="0.01") }}
                        {% if form.quantity.errors %}
                            {% for error in form.quantity.errors %}
                                <span class="text-danger">{{ error }}</span>
                            {% endfor %}
                        {% endif %}
                    </div>
                    
                    <div class="form-group" style="flex: 1;">
                        {{ form.unit.label(class="form-label") }}
                        {{ form.unit(class="form-select", id="unit-select") }}
                        {% if form.unit.errors %}
                            {% for error in form.unit.errors %}
                                <span class="text-danger">{{ error }}</span>
                            {% endfor %}
                        {% endif %}
                    </div>
                </div>
                
                <div class="form-group">
                    {{ form.expiry_date.label(class="form-label") }}
                    {{ form.expiry_date(class="form-control", type="date") }}
                    {% if form.expiry_date.errors %}
                        {% for error in form.expiry_date.errors %}
                            <span class="text-danger">{{ error }}</span>
                        {% endfor %}
                    {% endif %}
                </div>
                
                <div class="d-flex justify-content-between mt-4">
                    <a href="{{ url_for('inventory.index') }}" class="btn btn-outline">Cancel</a>
                    <button type="submit" class="btn btn-primary">Save Ingredient</button>
                </div>
            </form>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const ingredientInput = document.getElementById('ingredient-name-input');
    const suggestionsContainer = document.getElementById('ingredient-suggestions');
    const unitSelect = document.getElementById('unit-select');
    
    // Store the ingredient data
    let ingredientData = [];
    
    // Fetch ingredients
    async function fetchIngredients(searchTerm) {
        try {
            const response = await fetch(`/inventory/api/ingredients?term=${searchTerm}`);
            const data = await response.json();
            return data.ingredients;
        } catch (error) {
            console.error('Error fetching ingredients:', error);
            return [];
        }
    }
    
    // Debounce function to prevent too many API calls
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }
    
    // Handle input changes
    const handleInputChange = debounce(async function() {
        const searchTerm = ingredientInput.value.trim().toLowerCase();
        
        if (searchTerm.length < 2) {
            suggestionsContainer.innerHTML = '';
            suggestionsContainer.style.display = 'none';
            return;
        }
        
        // Fetch ingredients that match the search term
        ingredientData = await fetchIngredients(searchTerm);
        
        // Display suggestions
        if (ingredientData.length > 0) {
            suggestionsContainer.innerHTML = '';
            
            ingredientData.forEach(ingredient => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                div.textContent = ingredient.name;
                div.addEventListener('click', () => selectIngredient(ingredient));
                suggestionsContainer.appendChild(div);
            });
            
            suggestionsContainer.style.display = 'block';
        } else {
            suggestionsContainer.innerHTML = '';
            suggestionsContainer.style.display = 'none';
        }
    }, 300);
    
    // Select an ingredient from suggestions
    function selectIngredient(ingredient) {
        ingredientInput.value = ingredient.name;
        
        // Set the unit if available
        if (ingredient.unit) {
            // Find the option with this unit value
            for (let i = 0; i < unitSelect.options.length; i++) {
                if (unitSelect.options[i].value === ingredient.unit) {
                    unitSelect.selectedIndex = i;
                    break;
                }
            }
        }
        
        // Hide suggestions
        suggestionsContainer.innerHTML = '';
        suggestionsContainer.style.display = 'none';
    }
    
    // Add event listeners
    ingredientInput.addEventListener('input', handleInputChange);
    
    // Close suggestions when clicking outside
    document.addEventListener('click', function(event) {
        if (event.target !== ingredientInput && event.target !== suggestionsContainer) {
            suggestionsContainer.style.display = 'none';
        }
    });
});
</script>

<style>
.ingredient-suggestions {
    position: absolute;
    z-index: 10;
    background: white;
    border: 1px solid #ced4da;
    border-radius: 0.375rem;
    width: 100%;
    max-height: 200px;
    overflow-y: auto;
    display: none;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.suggestion-item {
    padding: 8px 12px;
    cursor: pointer;
}

.suggestion-item:hover {
    background-color: var(--gray-200);
}
</style>
{% endblock %}


........,.........................


{% extends "base.html" %}

{% block title %}CookBookIt - Meal Plan{% endblock %}

{% block content %}
<div class="slide-in-up">
    <h1 class="mb-4">Weekly Meal Plan</h1>
    <div class="d-flex justify-content-between mb-4">
        <div>
            <span class="text-muted">Week of {{ meal_plan.week_start_date.strftime('%B %d, %Y') }}</span>
        </div>
        <div>
            <a href="{{ url_for('meal_plan.grocery_list') }}" class="btn btn-outline me-2">
                <i class="fas fa-shopping-cart"></i> Grocery List
            </a>
            <form method="POST" action="{{ url_for('meal_plan.auto_generate') }}" class="d-inline">
                <button type="submit" class="btn btn-primary">
                    <i class="fas fa-magic"></i> Auto-Generate
                </button>
            </form>
        </div>
    </div>
    
    <div class="meal-plan-grid">
        <!-- Header -->
        <div class="time-slot-header"></div>
        {% for day in days_of_week %}
            <div class="day-header">{{ day.name }}</div>
        {% endfor %}
        
        <!-- Meal slots -->
        {% for meal_type in meal_types %}
            <div class="time-slot">{{ meal_type.name }}</div>
            
            {% for day in days_of_week %}
                <div class="meal-slot">
                    {% set meal = meal_schedule[day.id][meal_type.id] %}
                    
                    {% if meal %}
                        <div class="meal-card">
                            <img src="{{ url_for('static', filename=Recipe.get_image_path(meal.recipe._id, meal.recipe.image_url)) }}" alt="{{ meal.recipe.name }}" class="meal-img">
                            <div class="meal-details">
                                <h4>{{ meal.recipe.name }}</h4>
                                <div class="meal-meta">
                                    <span>{{ (meal.recipe.prep_time + meal.recipe.cook_time)|default(30) }} min</span>
                                    <span>{{ meal.recipe.difficulty|default('Medium') }}</span>
                                </div>
                                <div class="meal-card-actions">
                                    <a href="{{ url_for('recipe.detail', recipe_id=meal.recipe._id) }}" class="btn btn-sm btn-outline">
                                        View
                                    </a>
                                    <form method="POST" action="{{ url_for('meal_plan.remove_recipe', item_id=meal.id) }}" class="d-inline">
                                        <button type="submit" class="btn btn-sm btn-danger">
                                            Remove
                                        </button>
                                    </form>
                                </div>
                            </div>
                        </div>
                    {% else %}
                        <div class="empty-slot" id="empty-slot-{{ day.id }}-{{ meal_type.id }}">
                            <span>No meal planned</span>
                            <button type="button" class="btn btn-sm btn-primary add-recipe-btn" data-bs-toggle="modal" data-bs-target="#addRecipeModal" data-day="{{ day.id }}" data-meal-type="{{ meal_type.id }}">
                                Add Recipe
                            </button>
                        </div>
                    {% endif %}
                </div>
            {% endfor %}
        {% endfor %}
    </div>
</div>

<!-- Add Recipe Modal -->
<div class="modal fade" id="addRecipeModal" tabindex="-1" aria-labelledby="addRecipeModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="addRecipeModalLabel">Add Recipe to Meal Plan</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="searchForm" class="mb-4">
                    <div class="input-group">
                        <input type="text" id="searchInput" class="form-control" placeholder="Search recipes...">
                        <button type="submit" class="btn btn-primary">Search</button>
                    </div>
                </form>
                
                <div id="recipeResults" class="recipe-results-grid">
                    <!-- Recipe results will be loaded here -->
                </div>
                
                <div id="loadingIndicator" class="text-center d-none">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
                
                <div id="noResults" class="text-center d-none">
                    <p>No recipes found. Try a different search term.</p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Store the current day and meal type
        let currentDay = 0;
        let currentMealType = 'breakfast';
        
        // Add recipe button click event
        const addRecipeBtns = document.querySelectorAll('.add-recipe-btn');
        addRecipeBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                currentDay = this.dataset.day;
                currentMealType = this.dataset.mealType;
                
                // Clear previous search results
                document.getElementById('recipeResults').innerHTML = '';
                document.getElementById('searchInput').value = '';
                
                // Load suggestions
                loadSuggestions();
            });
        });
        
        // Search form submit event
        const searchForm = document.getElementById('searchForm');
        searchForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const searchTerm = document.getElementById('searchInput').value.trim();
            
            if (searchTerm) {
                searchRecipes(searchTerm);
            } else {
                loadSuggestions();
            }
        });
        
        // Load recipe suggestions
        function loadSuggestions() {
            const resultsContainer = document.getElementById('recipeResults');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const noResults = document.getElementById('noResults');
            
            // Show loading indicator
            resultsContainer.classList.add('d-none');
            noResults.classList.add('d-none');
            loadingIndicator.classList.remove('d-none');
            
            // Fetch suggestions from API
            fetch('/meal-plan/api/suggest')
                .then(response => response.json())
                .then(data => {
                    // Hide loading indicator
                    loadingIndicator.classList.add('d-none');
                    
                    if (data.suggestions && data.suggestions.length > 0) {
                        // Show results container
                        resultsContainer.classList.remove('d-none');
                        
                        // Clear previous results
                        resultsContainer.innerHTML = '<h4 class="mb-3">Suggested Recipes</h4>';
                        
                        // Add results to container
                        data.suggestions.forEach(recipe => {
                            resultsContainer.appendChild(createRecipeCard(recipe));
                        });
                    } else {
                        // Show no results message
                        noResults.classList.remove('d-none');
                    }
                })
                .catch(error => {
                    console.error('Error loading suggestions:', error);
                    loadingIndicator.classList.add('d-none');
                    noResults.classList.remove('d-none');
                });
        }
        
        // Search recipes
        function searchRecipes(searchTerm) {
            const resultsContainer = document.getElementById('recipeResults');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const noResults = document.getElementById('noResults');
            
            // Show loading indicator
            resultsContainer.classList.add('d-none');
            noResults.classList.add('d-none');
            loadingIndicator.classList.remove('d-none');
            
            // Fetch recipes from API
            fetch(`/recipe/search?term=${encodeURIComponent(searchTerm)}`)
                .then(response => response.text())
                .then(html => {
                    // Hide loading indicator
                    loadingIndicator.classList.add('d-none');
                    
                    // Extract recipes from HTML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const recipeCards = doc.querySelectorAll('.recipe-card');
                    
                    if (recipeCards.length > 0) {
                        // Show results container
                        resultsContainer.classList.remove('d-none');
                        
                        // Clear previous results
                        resultsContainer.innerHTML = '<h4 class="mb-3">Search Results</h4>';
                        
                        // Add results to container
                        recipeCards.forEach(card => {
                            const recipeName = card.querySelector('.card-title').textContent;
                            const recipeId = card.querySelector('a.btn-primary').href.split('/').pop();
                            const recipeImg = card.querySelector('.card-img').src;
                            
                            const recipeObj = {
                                id: recipeId,
                                name: recipeName,
                                image_url: recipeImg
                            };
                            
                            resultsContainer.appendChild(createRecipeCard(recipeObj));
                        });
                    } else {
                        // Show no results message
                        noResults.classList.remove('d-none');
                    }
                })
                .catch(error => {
                    console.error('Error searching recipes:', error);
                    loadingIndicator.classList.add('d-none');
                    noResults.classList.remove('d-none');
                });
        }
        
        // Create recipe card
        function createRecipeCard(recipe) {
            const card = document.createElement('div');
            card.className = 'modal-recipe-card';
            
            card.innerHTML = `
                <div class="recipe-card-content">
                    <img src="${recipe.image_url || `/static/images/recipes/${recipe.id}.jpg`}" onerror="this.src='/static/images/placeholder.jpg'" alt="${recipe.name}" class="recipe-thumbnail">
                    <div class="recipe-info">
                        <h4>${recipe.name}</h4>
                        ${recipe.match_percentage ? `<span class="match-badge">${Math.round(recipe.match_percentage)}% match</span>` : ''}
                        ${recipe.total_time ? `<span>${recipe.total_time} min</span>` : ''}
                    </div>
                </div>
                <form method="POST" action="/meal-plan/add/${recipe.id}">
                    <input type="hidden" name="day_of_week" value="${currentDay}">
                    <input type="hidden" name="meal_type" value="${currentMealType}">
                    <button type="submit" class="btn btn-primary btn-sm">Add to Plan</button>
                </form>
            `;
            
            return card;
        }
    });
</script>
{% endblock %}
..................................


{% extends "base.html" %}

{% block title %}CookBookIt - Grocery List{% endblock %}

{% block content %}
<div class="slide-in-up">
    <h1 class="mb-4">Grocery List</h1>
    <div class="mb-4">
        <span class="text-muted">Week of {{ meal_plan.week_start_date.strftime('%B %d, %Y') }}</span>
        <a href="{{ url_for('meal_plan.index') }}" class="btn btn-outline ms-3">
            <i class="fas fa-arrow-left"></i> Back to Meal Plan
        </a>
        <button class="btn btn-primary ms-2" onclick="window.print()">
            <i class="fas fa-print"></i> Print
        </button>
    </div>
    
    <div class="grocery-list-container">
        {% for category, items in categories.items() %}
            <div class="grocery-category">
                <h3>{{ category|title }}</h3>
                <ul class="grocery-items">
                    {% for item in items %}
                        <li class="grocery-item">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="item-{{ loop.index }}">
                                <label class="form-check-label" for="item-{{ loop.index }}">
                                    {{ item.name|title }}
                                    <span class="grocery-amount">
                                        {{ item.amount }} {{ item.unit }}
                                        {% if item.in_inventory == 'maybe' %}
                                            <span class="check-inventory">Check Inventory</span>
                                        {% endif %}
                                    </span>
                                </label>
                            </div>
                        </li>
                    {% endfor %}
                </ul>
            </div>
        {% else %}
            <div class="alert alert-info">
                <p>No items needed for your meal plan.</p>
                <p>Either you already have all the ingredients you need in your inventory, or your meal plan is empty.</p>
                <a href="{{ url_for('meal_plan.index') }}" class="btn btn-primary mt-3">Update Meal Plan</a>
            </div>
        {% endfor %}
    </div>
</div>
{% endblock %}

{% block styles %}
<style>
@media print {
    header, footer, .btn, form {
        display: none !important;
    }
    
    body {
        padding: 0;
        margin: 0;
    }
    
    .grocery-list-container {
        margin: 0;
        padding: 0;
    }
    
    .container {
        max-width: 100%;
        width: 100%;
        padding: 0;
        margin: 0;
    }
}

.grocery-category {
    margin-bottom: 2rem;
}

.grocery-category h3 {
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--gray-300);
    margin-bottom: 1rem;
}

.grocery-items {
    list-style-type: none;
    padding-left: 0;
}

.grocery-item {
    padding: 0.5rem 0;
    border-bottom: 1px solid var(--gray-100);
}

.grocery-amount {
    color: var(--gray-500);
    margin-left: 0.5rem;
}

.check-inventory {
    display: inline-block;
    font-size: 0.75rem;
    padding: 0.125rem 0.375rem;
    background-color: var(--yellow-100);
    color: var(--yellow-800);
    border-radius: 1rem;
    margin-left: 0.5rem;
}

.form-check-input:checked + .form-check-label {
    text-decoration: line-through;
    color: var(--gray-500);
}
</style>
{% endblock %}

..................................











